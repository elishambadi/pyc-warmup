{% extends "base.html" %}
{% load static %}
{% load custom_filters %}

{% block content %}
<div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-10">
    
    <h2 class="text-3xl sm:text-4xl font-extrabold text-pyc-text mb-2">Sync Lyrics - {{ mp3_file.voice_part }}</h2>
    <h3 class="text-xl text-pyc-text/70 font-medium mb-6">{{ song.title }}</h3>

    <div class="p-4 sm:p-6 mb-6 rounded-xl bg-gray-50 border border-pyc-purple/10 shadow-lg">
        <h4 class="text-xl font-semibold text-pyc-purple mb-3 flex items-center">
            <span class="mr-2 text-2xl">ðŸŽµ</span> Syncing Instructions
        </h4>
        <ol class="list-decimal list-inside text-pyc-text space-y-2 ml-4">
            <li>Click <strong class="text-pyc-orange">Play</strong> to start the audio</li>
            <li>Click <strong class="text-pyc-purple">Set Timestamp</strong> when you hear each line</li>
            <li>Use <strong class="text-red-500">Delete</strong> to remove incorrect timestamps</li>
        </ol>
    </div>

    <audio 
        id="audio-player" 
        controls 
        class="w-full mb-8 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-pyc-purple" 
        data-mp3-id="{{ mp3_file.id }}"
    >
        <source src="{{ mp3_file.file.url }}" type="audio/mpeg">
    </audio>

    <div id="lyrics-container" class="space-y-4">
        {% for lyric in lyrics %}
        <p class="lyric-line flex items-center justify-between p-3 rounded-lg hover:bg-pyc-purple/5 transition duration-150 border-b border-gray-200" data-lyric-id="{{ lyric.id }}">
            
            <span class="flex-grow text-lg text-pyc-text mr-4">
                {{ lyric.text }}
            </span>
            
            <span class="flex items-center space-x-3 text-sm">
                <span class="timestamp-display text-pyc-orange font-mono font-semibold min-w-[70px] text-right">
                    {% if timestamps|get_item:lyric.id %}
                    [{{ timestamps|get_item:lyric.id|floatformat:2 }}s]
                    {% endif %}
                </span>

                <button class="sync-btn px-3 py-1 bg-pyc-purple text-white rounded-md hover:bg-pyc-purple/90 transition duration-150 text-xs font-medium shadow-sm">
                    Set Timestamp
                </button>
                
                <button class="delete-btn px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 transition duration-150 text-xs font-medium shadow-sm">
                    Delete
                </button>
            </span>
        </p>
        {% endfor %}
    </div>

    <div class="mt-8 pt-4 border-t border-gray-200">
        <a href="{% url 'song_detail' song.slug %}" class="px-6 py-2 bg-pyc-green text-white rounded-lg shadow-md hover:bg-pyc-green/90 transition duration-150 font-medium">
            Back to Song
        </a>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const audioPlayer = document.getElementById('audio-player');
        const mp3Id = audioPlayer.dataset.mp3Id;

        // Load existing timestamps when page loads
        loadTimestamps(mp3Id);

        // Handle timestamp setting
        document.querySelectorAll('.sync-btn').forEach(button => {
            button.addEventListener('click', function () {
                const lyricLine = this.closest('.lyric-line');
                const lyricId = lyricLine.dataset.lyricId;
                const currentTime = audioPlayer.currentTime;

                saveTimestamp(lyricId, mp3Id, currentTime, lyricLine);
            });
        });

        // Handle timestamp deletion
        document.querySelectorAll('.delete-btn').forEach(button => {
            button.addEventListener('click', function () {
                const lyricLine = this.closest('.lyric-line');
                const lyricId = lyricLine.dataset.lyricId;

                if (confirm('Delete this timestamp?')) {
                    deleteTimestamp(lyricId, mp3Id, lyricLine);
                }
            });
        });
    });

    function saveTimestamp(lyricId, mp3Id, timestamp, lyricLine) {
        fetch('/save-timestamp/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                lyric_id: lyricId,
                mp3_id: mp3Id,
                timestamp: timestamp
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const timestampDisplay = lyricLine.querySelector('.timestamp-display');
                    timestampDisplay.textContent = `[${timestamp.toFixed(2)}s]`;
                    lyricLine.classList.add('synced');
                }
            })
            .catch(error => {
                console.error('Error saving timestamp:', error);
                alert('Failed to save timestamp');
            });
    }

    function deleteTimestamp(lyricId, mp3Id, lyricLine) {
        fetch('/delete-timestamp/', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                lyric_id: lyricId,
                mp3_id: mp3Id
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const timestampDisplay = lyricLine.querySelector('.timestamp-display');
                timestampDisplay.textContent = '';
                lyricLine.classList.remove('synced');
            }
        })
        .catch(error => {
            console.error('Error deleting timestamp:', error);
            alert('Failed to delete timestamp');
        });
    }

    function loadTimestamps(mp3Id) {
        fetch(`/get-timestamps/${mp3Id}/`)
            .then(response => response.json())
            .then(data => {
                data.timestamps.forEach(ts => {
                    const lyricLine = document.querySelector(`.lyric-line[data-lyric-id="${ts.lyric_id}"]`);
                    if (lyricLine) {
                        const timestampDisplay = lyricLine.querySelector('.timestamp-display');
                        timestampDisplay.textContent = `[${ts.timestamp.toFixed(2)}s]`;
                        lyricLine.classList.add('synced');
                    }
                });
            })
            .catch(error => {
                console.error('Error loading timestamps:', error);
            });
    }

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

</script>
<!-- <script type="text/javascript" src="{% static 'js/sync_lyrics.js' %}"></script> -->
{% endblock %}